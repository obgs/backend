// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/obgs/backend/internal/ent/game"
	"github.com/obgs/backend/internal/ent/gameversion"
	"github.com/obgs/backend/internal/ent/group"
	"github.com/obgs/backend/internal/ent/groupmembership"
	"github.com/obgs/backend/internal/ent/groupmembershipapplication"
	"github.com/obgs/backend/internal/ent/groupsettings"
	"github.com/obgs/backend/internal/ent/match"
	"github.com/obgs/backend/internal/ent/player"
	"github.com/obgs/backend/internal/ent/playersupervisionrequest"
	"github.com/obgs/backend/internal/ent/playersupervisionrequestapproval"
	"github.com/obgs/backend/internal/ent/schema/guidgql"
	"github.com/obgs/backend/internal/ent/statdescription"
	"github.com/obgs/backend/internal/ent/statistic"
	"github.com/obgs/backend/internal/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ga *GameQuery) CollectFields(ctx context.Context, satisfies ...string) (*GameQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ga, nil
	}
	if err := ga.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ga, nil
}

func (ga *GameQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(game.Columns))
		selectedFields = []string{game.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "author":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ga.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ga.withAuthor = query
		case "name":
			if _, ok := fieldSeen[game.FieldName]; !ok {
				selectedFields = append(selectedFields, game.FieldName)
				fieldSeen[game.FieldName] = struct{}{}
			}
		case "minPlayers":
			if _, ok := fieldSeen[game.FieldMinPlayers]; !ok {
				selectedFields = append(selectedFields, game.FieldMinPlayers)
				fieldSeen[game.FieldMinPlayers] = struct{}{}
			}
		case "maxPlayers":
			if _, ok := fieldSeen[game.FieldMaxPlayers]; !ok {
				selectedFields = append(selectedFields, game.FieldMaxPlayers)
				fieldSeen[game.FieldMaxPlayers] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[game.FieldDescription]; !ok {
				selectedFields = append(selectedFields, game.FieldDescription)
				fieldSeen[game.FieldDescription] = struct{}{}
			}
		case "boardgamegeekURL":
			if _, ok := fieldSeen[game.FieldBoardgamegeekURL]; !ok {
				selectedFields = append(selectedFields, game.FieldBoardgamegeekURL)
				fieldSeen[game.FieldBoardgamegeekURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ga.Select(selectedFields...)
	}
	return nil
}

type gamePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GamePaginateOption
}

func newGamePaginateArgs(rv map[string]any) *gamePaginateArgs {
	args := &gamePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GameWhereInput); ok {
		args.opts = append(args.opts, WithGameFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gv *GameVersionQuery) CollectFields(ctx context.Context, satisfies ...string) (*GameVersionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gv, nil
	}
	if err := gv.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gv, nil
}

func (gv *GameVersionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(gameversion.Columns))
		selectedFields = []string{gameversion.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "game":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GameClient{config: gv.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, gameImplementors)...); err != nil {
				return err
			}
			gv.withGame = query

		case "statDescriptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatDescriptionClient{config: gv.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, statdescriptionImplementors)...); err != nil {
				return err
			}
			gv.WithNamedStatDescriptions(alias, func(wq *StatDescriptionQuery) {
				*wq = *query
			})
		case "versionNumber":
			if _, ok := fieldSeen[gameversion.FieldVersionNumber]; !ok {
				selectedFields = append(selectedFields, gameversion.FieldVersionNumber)
				fieldSeen[gameversion.FieldVersionNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gv.Select(selectedFields...)
	}
	return nil
}

type gameversionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GameVersionPaginateOption
}

func newGameVersionPaginateArgs(rv map[string]any) *gameversionPaginateArgs {
	args := &gameversionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GameVersionWhereInput); ok {
		args.opts = append(args.opts, WithGameVersionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gr *GroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gr, nil
	}
	if err := gr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gr, nil
}

func (gr *GroupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(group.Columns))
		selectedFields = []string{group.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "settings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupSettingsClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupsettingsImplementors)...); err != nil {
				return err
			}
			gr.withSettings = query

		case "members":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: gr.config}).Query()
			)
			args := newGroupMembershipPaginateArgs(fieldArgs(ctx, new(GroupMembershipWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newGroupMembershipPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					gr.loadTotal = append(gr.loadTotal, func(ctx context.Context, nodes []*Group) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID guidgql.GUID `sql:"group_members"`
							Count  int          `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(group.MembersColumn), ids...))
						})
						if err := query.GroupBy(group.MembersColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[guidgql.GUID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				} else {
					gr.loadTotal = append(gr.loadTotal, func(_ context.Context, nodes []*Group) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Members)
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(group.MembersColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			gr.WithNamedMembers(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})

		case "applications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipApplicationClient{config: gr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipapplicationImplementors)...); err != nil {
				return err
			}
			gr.WithNamedApplications(alias, func(wq *GroupMembershipApplicationQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[group.FieldName]; !ok {
				selectedFields = append(selectedFields, group.FieldName)
				fieldSeen[group.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[group.FieldDescription]; !ok {
				selectedFields = append(selectedFields, group.FieldDescription)
				fieldSeen[group.FieldDescription] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[group.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, group.FieldLogoURL)
				fieldSeen[group.FieldLogoURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gr.Select(selectedFields...)
	}
	return nil
}

type groupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupPaginateOption
}

func newGroupPaginateArgs(rv map[string]any) *groupPaginateArgs {
	args := &groupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupWhereInput); ok {
		args.opts = append(args.opts, WithGroupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gm *GroupMembershipQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupMembershipQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gm, nil
	}
	if err := gm.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gm, nil
}

func (gm *GroupMembershipQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupmembership.Columns))
		selectedFields = []string{groupmembership.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			gm.withGroup = query

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gm.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gm.withUser = query
		case "role":
			if _, ok := fieldSeen[groupmembership.FieldRole]; !ok {
				selectedFields = append(selectedFields, groupmembership.FieldRole)
				fieldSeen[groupmembership.FieldRole] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gm.Select(selectedFields...)
	}
	return nil
}

type groupmembershipPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupMembershipPaginateOption
}

func newGroupMembershipPaginateArgs(rv map[string]any) *groupmembershipPaginateArgs {
	args := &groupmembershipPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupMembershipWhereInput); ok {
		args.opts = append(args.opts, WithGroupMembershipFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gma *GroupMembershipApplicationQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupMembershipApplicationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gma, nil
	}
	if err := gma.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gma, nil
}

func (gma *GroupMembershipApplicationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupmembershipapplication.Columns))
		selectedFields = []string{groupmembershipapplication.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: gma.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			gma.withUser = query

		case "group":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupClient{config: gma.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, groupImplementors)...); err != nil {
				return err
			}
			gma.withGroup = query
		case "message":
			if _, ok := fieldSeen[groupmembershipapplication.FieldMessage]; !ok {
				selectedFields = append(selectedFields, groupmembershipapplication.FieldMessage)
				fieldSeen[groupmembershipapplication.FieldMessage] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gma.Select(selectedFields...)
	}
	return nil
}

type groupmembershipapplicationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupMembershipApplicationPaginateOption
}

func newGroupMembershipApplicationPaginateArgs(rv map[string]any) *groupmembershipapplicationPaginateArgs {
	args := &groupmembershipapplicationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gs *GroupSettingsQuery) CollectFields(ctx context.Context, satisfies ...string) (*GroupSettingsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gs, nil
	}
	if err := gs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gs, nil
}

func (gs *GroupSettingsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(groupsettings.Columns))
		selectedFields = []string{groupsettings.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "visibility":
			if _, ok := fieldSeen[groupsettings.FieldVisibility]; !ok {
				selectedFields = append(selectedFields, groupsettings.FieldVisibility)
				fieldSeen[groupsettings.FieldVisibility] = struct{}{}
			}
		case "joinPolicy":
			if _, ok := fieldSeen[groupsettings.FieldJoinPolicy]; !ok {
				selectedFields = append(selectedFields, groupsettings.FieldJoinPolicy)
				fieldSeen[groupsettings.FieldJoinPolicy] = struct{}{}
			}
		case "minimumRoleToInvite":
			if _, ok := fieldSeen[groupsettings.FieldMinimumRoleToInvite]; !ok {
				selectedFields = append(selectedFields, groupsettings.FieldMinimumRoleToInvite)
				fieldSeen[groupsettings.FieldMinimumRoleToInvite] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gs.Select(selectedFields...)
	}
	return nil
}

type groupsettingsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GroupSettingsPaginateOption
}

func newGroupSettingsPaginateArgs(rv map[string]any) *groupsettingsPaginateArgs {
	args := &groupsettingsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*GroupSettingsWhereInput); ok {
		args.opts = append(args.opts, WithGroupSettingsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MatchQuery) CollectFields(ctx context.Context, satisfies ...string) (*MatchQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MatchQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(match.Columns))
		selectedFields = []string{match.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "gameVersion":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GameVersionClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, gameversionImplementors)...); err != nil {
				return err
			}
			m.withGameVersion = query

		case "players":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, playerImplementors)...); err != nil {
				return err
			}
			m.WithNamedPlayers(alias, func(wq *PlayerQuery) {
				*wq = *query
			})

		case "stats":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatisticClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, statisticImplementors)...); err != nil {
				return err
			}
			m.WithNamedStats(alias, func(wq *StatisticQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[match.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, match.FieldCreatedAt)
				fieldSeen[match.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type matchPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MatchPaginateOption
}

func newMatchPaginateArgs(rv map[string]any) *matchPaginateArgs {
	args := &matchPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*MatchWhereInput); ok {
		args.opts = append(args.opts, WithMatchFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pl *PlayerQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlayerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pl, nil
	}
	if err := pl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pl, nil
}

func (pl *PlayerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(player.Columns))
		selectedFields = []string{player.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pl.withOwner = query

		case "supervisors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pl.WithNamedSupervisors(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "supervisionRequests":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerSupervisionRequestClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, playersupervisionrequestImplementors)...); err != nil {
				return err
			}
			pl.WithNamedSupervisionRequests(alias, func(wq *PlayerSupervisionRequestQuery) {
				*wq = *query
			})

		case "matches":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MatchClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, matchImplementors)...); err != nil {
				return err
			}
			pl.WithNamedMatches(alias, func(wq *MatchQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[player.FieldName]; !ok {
				selectedFields = append(selectedFields, player.FieldName)
				fieldSeen[player.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pl.Select(selectedFields...)
	}
	return nil
}

type playerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlayerPaginateOption
}

func newPlayerPaginateArgs(rv map[string]any) *playerPaginateArgs {
	args := &playerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PlayerWhereInput); ok {
		args.opts = append(args.opts, WithPlayerFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (psr *PlayerSupervisionRequestQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlayerSupervisionRequestQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return psr, nil
	}
	if err := psr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return psr, nil
}

func (psr *PlayerSupervisionRequestQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(playersupervisionrequest.Columns))
		selectedFields = []string{playersupervisionrequest.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "sender":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: psr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			psr.withSender = query

		case "player":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerClient{config: psr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, playerImplementors)...); err != nil {
				return err
			}
			psr.withPlayer = query

		case "approvals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerSupervisionRequestApprovalClient{config: psr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, playersupervisionrequestapprovalImplementors)...); err != nil {
				return err
			}
			psr.WithNamedApprovals(alias, func(wq *PlayerSupervisionRequestApprovalQuery) {
				*wq = *query
			})
		case "message":
			if _, ok := fieldSeen[playersupervisionrequest.FieldMessage]; !ok {
				selectedFields = append(selectedFields, playersupervisionrequest.FieldMessage)
				fieldSeen[playersupervisionrequest.FieldMessage] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		psr.Select(selectedFields...)
	}
	return nil
}

type playersupervisionrequestPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlayerSupervisionRequestPaginateOption
}

func newPlayerSupervisionRequestPaginateArgs(rv map[string]any) *playersupervisionrequestPaginateArgs {
	args := &playersupervisionrequestPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PlayerSupervisionRequestWhereInput); ok {
		args.opts = append(args.opts, WithPlayerSupervisionRequestFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (psra *PlayerSupervisionRequestApprovalQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlayerSupervisionRequestApprovalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return psra, nil
	}
	if err := psra.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return psra, nil
}

func (psra *PlayerSupervisionRequestApprovalQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(playersupervisionrequestapproval.Columns))
		selectedFields = []string{playersupervisionrequestapproval.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "approver":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: psra.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			psra.withApprover = query

		case "supervisionRequest":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerSupervisionRequestClient{config: psra.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, playersupervisionrequestImplementors)...); err != nil {
				return err
			}
			psra.withSupervisionRequest = query
		case "approved":
			if _, ok := fieldSeen[playersupervisionrequestapproval.FieldApproved]; !ok {
				selectedFields = append(selectedFields, playersupervisionrequestapproval.FieldApproved)
				fieldSeen[playersupervisionrequestapproval.FieldApproved] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		psra.Select(selectedFields...)
	}
	return nil
}

type playersupervisionrequestapprovalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlayerSupervisionRequestApprovalPaginateOption
}

func newPlayerSupervisionRequestApprovalPaginateArgs(rv map[string]any) *playersupervisionrequestapprovalPaginateArgs {
	args := &playersupervisionrequestapprovalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PlayerSupervisionRequestApprovalWhereInput); ok {
		args.opts = append(args.opts, WithPlayerSupervisionRequestApprovalFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sd *StatDescriptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*StatDescriptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sd, nil
	}
	if err := sd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sd, nil
}

func (sd *StatDescriptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(statdescription.Columns))
		selectedFields = []string{statdescription.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "type":
			if _, ok := fieldSeen[statdescription.FieldType]; !ok {
				selectedFields = append(selectedFields, statdescription.FieldType)
				fieldSeen[statdescription.FieldType] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[statdescription.FieldName]; !ok {
				selectedFields = append(selectedFields, statdescription.FieldName)
				fieldSeen[statdescription.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[statdescription.FieldDescription]; !ok {
				selectedFields = append(selectedFields, statdescription.FieldDescription)
				fieldSeen[statdescription.FieldDescription] = struct{}{}
			}
		case "metadata":
			if _, ok := fieldSeen[statdescription.FieldMetadata]; !ok {
				selectedFields = append(selectedFields, statdescription.FieldMetadata)
				fieldSeen[statdescription.FieldMetadata] = struct{}{}
			}
		case "orderNumber":
			if _, ok := fieldSeen[statdescription.FieldOrderNumber]; !ok {
				selectedFields = append(selectedFields, statdescription.FieldOrderNumber)
				fieldSeen[statdescription.FieldOrderNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sd.Select(selectedFields...)
	}
	return nil
}

type statdescriptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []StatDescriptionPaginateOption
}

func newStatDescriptionPaginateArgs(rv map[string]any) *statdescriptionPaginateArgs {
	args := &statdescriptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *StatisticQuery) CollectFields(ctx context.Context, satisfies ...string) (*StatisticQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *StatisticQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(statistic.Columns))
		selectedFields = []string{statistic.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "match":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MatchClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, matchImplementors)...); err != nil {
				return err
			}
			s.withMatch = query

		case "statDescription":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatDescriptionClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, statdescriptionImplementors)...); err != nil {
				return err
			}
			s.withStatDescription = query

		case "player":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, playerImplementors)...); err != nil {
				return err
			}
			s.withPlayer = query
		case "value":
			if _, ok := fieldSeen[statistic.FieldValue]; !ok {
				selectedFields = append(selectedFields, statistic.FieldValue)
				fieldSeen[statistic.FieldValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type statisticPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []StatisticPaginateOption
}

func newStatisticPaginateArgs(rv map[string]any) *statisticPaginateArgs {
	args := &statisticPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "players":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, playerImplementors)...); err != nil {
				return err
			}
			u.WithNamedPlayers(alias, func(wq *PlayerQuery) {
				*wq = *query
			})

		case "mainPlayer":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlayerClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, playerImplementors)...); err != nil {
				return err
			}
			u.withMainPlayer = query

		case "groupMemberships":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipImplementors)...); err != nil {
				return err
			}
			u.WithNamedGroupMemberships(alias, func(wq *GroupMembershipQuery) {
				*wq = *query
			})

		case "groupMembershipApplications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GroupMembershipApplicationClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, groupmembershipapplicationImplementors)...); err != nil {
				return err
			}
			u.WithNamedGroupMembershipApplications(alias, func(wq *GroupMembershipApplicationQuery) {
				*wq = *query
			})

		case "games":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GameClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, gameImplementors)...); err != nil {
				return err
			}
			u.WithNamedGames(alias, func(wq *GameQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "avatarURL":
			if _, ok := fieldSeen[user.FieldAvatarURL]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatarURL)
				fieldSeen[user.FieldAvatarURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
