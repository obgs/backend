// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/open-boardgame-stats/backend/internal/ent/game"
	"github.com/open-boardgame-stats/backend/internal/ent/gameversion"
	"github.com/open-boardgame-stats/backend/internal/ent/group"
	"github.com/open-boardgame-stats/backend/internal/ent/groupmembership"
	"github.com/open-boardgame-stats/backend/internal/ent/groupmembershipapplication"
	"github.com/open-boardgame-stats/backend/internal/ent/groupsettings"
	"github.com/open-boardgame-stats/backend/internal/ent/match"
	"github.com/open-boardgame-stats/backend/internal/ent/player"
	"github.com/open-boardgame-stats/backend/internal/ent/playersupervisionrequest"
	"github.com/open-boardgame-stats/backend/internal/ent/playersupervisionrequestapproval"
	"github.com/open-boardgame-stats/backend/internal/ent/schema/guidgql"
	"github.com/open-boardgame-stats/backend/internal/ent/statdescription"
	"github.com/open-boardgame-stats/backend/internal/ent/statistic"
	"github.com/open-boardgame-stats/backend/internal/ent/user"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[guidgql.GUID]
	PageInfo       = entgql.PageInfo[guidgql.GUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// GameEdge is the edge representation of Game.
type GameEdge struct {
	Node   *Game  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GameConnection is the connection containing edges to Game.
type GameConnection struct {
	Edges      []*GameEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *GameConnection) build(nodes []*Game, pager *gamePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Game
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Game {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Game {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GamePaginateOption enables pagination customization.
type GamePaginateOption func(*gamePager) error

// WithGameOrder configures pagination ordering.
func WithGameOrder(order *GameOrder) GamePaginateOption {
	if order == nil {
		order = DefaultGameOrder
	}
	o := *order
	return func(pager *gamePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameFilter configures pagination filter.
func WithGameFilter(filter func(*GameQuery) (*GameQuery, error)) GamePaginateOption {
	return func(pager *gamePager) error {
		if filter == nil {
			return errors.New("GameQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamePager struct {
	reverse bool
	order   *GameOrder
	filter  func(*GameQuery) (*GameQuery, error)
}

func newGamePager(opts []GamePaginateOption, reverse bool) (*gamePager, error) {
	pager := &gamePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameOrder
	}
	return pager, nil
}

func (p *gamePager) applyFilter(query *GameQuery) (*GameQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamePager) toCursor(ga *Game) Cursor {
	return p.order.Field.toCursor(ga)
}

func (p *gamePager) applyCursors(query *GameQuery, after, before *Cursor) (*GameQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamePager) applyOrder(query *GameQuery) *GameQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameOrder.Field {
		query = query.Order(DefaultGameOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamePager) orderExpr(query *GameQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameOrder.Field {
			b.Comma().Ident(DefaultGameOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Game.
func (ga *GameQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GamePaginateOption,
) (*GameConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGamePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ga, err = pager.applyFilter(ga); err != nil {
		return nil, err
	}
	conn := &GameConnection{Edges: []*GameEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ga.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ga, err = pager.applyCursors(ga, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ga.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ga.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ga = pager.applyOrder(ga)
	nodes, err := ga.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameOrderField defines the ordering field of Game.
type GameOrderField struct {
	// Value extracts the ordering value from the given Game.
	Value    func(*Game) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) game.OrderOption
	toCursor func(*Game) Cursor
}

// GameOrder defines the ordering of Game.
type GameOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *GameOrderField `json:"field"`
}

// DefaultGameOrder is the default ordering of Game.
var DefaultGameOrder = &GameOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameOrderField{
		Value: func(ga *Game) (ent.Value, error) {
			return ga.ID, nil
		},
		column: game.FieldID,
		toTerm: game.ByID,
		toCursor: func(ga *Game) Cursor {
			return Cursor{ID: ga.ID}
		},
	},
}

// ToEdge converts Game into GameEdge.
func (ga *Game) ToEdge(order *GameOrder) *GameEdge {
	if order == nil {
		order = DefaultGameOrder
	}
	return &GameEdge{
		Node:   ga,
		Cursor: order.Field.toCursor(ga),
	}
}

// GameVersionEdge is the edge representation of GameVersion.
type GameVersionEdge struct {
	Node   *GameVersion `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// GameVersionConnection is the connection containing edges to GameVersion.
type GameVersionConnection struct {
	Edges      []*GameVersionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *GameVersionConnection) build(nodes []*GameVersion, pager *gameversionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GameVersion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameVersion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameVersion {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameVersionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameVersionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GameVersionPaginateOption enables pagination customization.
type GameVersionPaginateOption func(*gameversionPager) error

// WithGameVersionOrder configures pagination ordering.
func WithGameVersionOrder(order *GameVersionOrder) GameVersionPaginateOption {
	if order == nil {
		order = DefaultGameVersionOrder
	}
	o := *order
	return func(pager *gameversionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameVersionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameVersionFilter configures pagination filter.
func WithGameVersionFilter(filter func(*GameVersionQuery) (*GameVersionQuery, error)) GameVersionPaginateOption {
	return func(pager *gameversionPager) error {
		if filter == nil {
			return errors.New("GameVersionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gameversionPager struct {
	reverse bool
	order   *GameVersionOrder
	filter  func(*GameVersionQuery) (*GameVersionQuery, error)
}

func newGameVersionPager(opts []GameVersionPaginateOption, reverse bool) (*gameversionPager, error) {
	pager := &gameversionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameVersionOrder
	}
	return pager, nil
}

func (p *gameversionPager) applyFilter(query *GameVersionQuery) (*GameVersionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gameversionPager) toCursor(gv *GameVersion) Cursor {
	return p.order.Field.toCursor(gv)
}

func (p *gameversionPager) applyCursors(query *GameVersionQuery, after, before *Cursor) (*GameVersionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameVersionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gameversionPager) applyOrder(query *GameVersionQuery) *GameVersionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameVersionOrder.Field {
		query = query.Order(DefaultGameVersionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gameversionPager) orderExpr(query *GameVersionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameVersionOrder.Field {
			b.Comma().Ident(DefaultGameVersionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GameVersion.
func (gv *GameVersionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameVersionPaginateOption,
) (*GameVersionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameVersionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gv, err = pager.applyFilter(gv); err != nil {
		return nil, err
	}
	conn := &GameVersionConnection{Edges: []*GameVersionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gv.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gv, err = pager.applyCursors(gv, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gv.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gv = pager.applyOrder(gv)
	nodes, err := gv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameVersionOrderField defines the ordering field of GameVersion.
type GameVersionOrderField struct {
	// Value extracts the ordering value from the given GameVersion.
	Value    func(*GameVersion) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) gameversion.OrderOption
	toCursor func(*GameVersion) Cursor
}

// GameVersionOrder defines the ordering of GameVersion.
type GameVersionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *GameVersionOrderField `json:"field"`
}

// DefaultGameVersionOrder is the default ordering of GameVersion.
var DefaultGameVersionOrder = &GameVersionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameVersionOrderField{
		Value: func(gv *GameVersion) (ent.Value, error) {
			return gv.ID, nil
		},
		column: gameversion.FieldID,
		toTerm: gameversion.ByID,
		toCursor: func(gv *GameVersion) Cursor {
			return Cursor{ID: gv.ID}
		},
	},
}

// ToEdge converts GameVersion into GameVersionEdge.
func (gv *GameVersion) ToEdge(order *GameVersionOrder) *GameVersionEdge {
	if order == nil {
		order = DefaultGameVersionOrder
	}
	return &GameVersionEdge{
		Node:   gv,
		Cursor: order.Field.toCursor(gv),
	}
}

// GroupEdge is the edge representation of Group.
type GroupEdge struct {
	Node   *Group `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// GroupConnection is the connection containing edges to Group.
type GroupConnection struct {
	Edges      []*GroupEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *GroupConnection) build(nodes []*Group, pager *groupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Group
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Group {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Group {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupPaginateOption enables pagination customization.
type GroupPaginateOption func(*groupPager) error

// WithGroupOrder configures pagination ordering.
func WithGroupOrder(order *GroupOrder) GroupPaginateOption {
	if order == nil {
		order = DefaultGroupOrder
	}
	o := *order
	return func(pager *groupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupFilter configures pagination filter.
func WithGroupFilter(filter func(*GroupQuery) (*GroupQuery, error)) GroupPaginateOption {
	return func(pager *groupPager) error {
		if filter == nil {
			return errors.New("GroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupPager struct {
	reverse bool
	order   *GroupOrder
	filter  func(*GroupQuery) (*GroupQuery, error)
}

func newGroupPager(opts []GroupPaginateOption, reverse bool) (*groupPager, error) {
	pager := &groupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupOrder
	}
	return pager, nil
}

func (p *groupPager) applyFilter(query *GroupQuery) (*GroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupPager) toCursor(gr *Group) Cursor {
	return p.order.Field.toCursor(gr)
}

func (p *groupPager) applyCursors(query *GroupQuery, after, before *Cursor) (*GroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupPager) applyOrder(query *GroupQuery) *GroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupOrder.Field {
		query = query.Order(DefaultGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupPager) orderExpr(query *GroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupOrder.Field {
			b.Comma().Ident(DefaultGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Group.
func (gr *GroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupPaginateOption,
) (*GroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gr, err = pager.applyFilter(gr); err != nil {
		return nil, err
	}
	conn := &GroupConnection{Edges: []*GroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gr, err = pager.applyCursors(gr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gr = pager.applyOrder(gr)
	nodes, err := gr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupOrderField defines the ordering field of Group.
type GroupOrderField struct {
	// Value extracts the ordering value from the given Group.
	Value    func(*Group) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) group.OrderOption
	toCursor func(*Group) Cursor
}

// GroupOrder defines the ordering of Group.
type GroupOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *GroupOrderField `json:"field"`
}

// DefaultGroupOrder is the default ordering of Group.
var DefaultGroupOrder = &GroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupOrderField{
		Value: func(gr *Group) (ent.Value, error) {
			return gr.ID, nil
		},
		column: group.FieldID,
		toTerm: group.ByID,
		toCursor: func(gr *Group) Cursor {
			return Cursor{ID: gr.ID}
		},
	},
}

// ToEdge converts Group into GroupEdge.
func (gr *Group) ToEdge(order *GroupOrder) *GroupEdge {
	if order == nil {
		order = DefaultGroupOrder
	}
	return &GroupEdge{
		Node:   gr,
		Cursor: order.Field.toCursor(gr),
	}
}

// GroupMembershipEdge is the edge representation of GroupMembership.
type GroupMembershipEdge struct {
	Node   *GroupMembership `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// GroupMembershipConnection is the connection containing edges to GroupMembership.
type GroupMembershipConnection struct {
	Edges      []*GroupMembershipEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *GroupMembershipConnection) build(nodes []*GroupMembership, pager *groupmembershipPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupMembership
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembership {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembership {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipPaginateOption enables pagination customization.
type GroupMembershipPaginateOption func(*groupmembershipPager) error

// WithGroupMembershipOrder configures pagination ordering.
func WithGroupMembershipOrder(order *GroupMembershipOrder) GroupMembershipPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	o := *order
	return func(pager *groupmembershipPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipFilter configures pagination filter.
func WithGroupMembershipFilter(filter func(*GroupMembershipQuery) (*GroupMembershipQuery, error)) GroupMembershipPaginateOption {
	return func(pager *groupmembershipPager) error {
		if filter == nil {
			return errors.New("GroupMembershipQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershipPager struct {
	reverse bool
	order   *GroupMembershipOrder
	filter  func(*GroupMembershipQuery) (*GroupMembershipQuery, error)
}

func newGroupMembershipPager(opts []GroupMembershipPaginateOption, reverse bool) (*groupmembershipPager, error) {
	pager := &groupmembershipPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipOrder
	}
	return pager, nil
}

func (p *groupmembershipPager) applyFilter(query *GroupMembershipQuery) (*GroupMembershipQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershipPager) toCursor(gm *GroupMembership) Cursor {
	return p.order.Field.toCursor(gm)
}

func (p *groupmembershipPager) applyCursors(query *GroupMembershipQuery, after, before *Cursor) (*GroupMembershipQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershipPager) applyOrder(query *GroupMembershipQuery) *GroupMembershipQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipOrder.Field {
		query = query.Order(DefaultGroupMembershipOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershipPager) orderExpr(query *GroupMembershipQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembership.
func (gm *GroupMembershipQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipPaginateOption,
) (*GroupMembershipConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gm, err = pager.applyFilter(gm); err != nil {
		return nil, err
	}
	conn := &GroupMembershipConnection{Edges: []*GroupMembershipEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gm.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gm, err = pager.applyCursors(gm, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gm.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gm = pager.applyOrder(gm)
	nodes, err := gm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupMembershipOrderField defines the ordering field of GroupMembership.
type GroupMembershipOrderField struct {
	// Value extracts the ordering value from the given GroupMembership.
	Value    func(*GroupMembership) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembership.OrderOption
	toCursor func(*GroupMembership) Cursor
}

// GroupMembershipOrder defines the ordering of GroupMembership.
type GroupMembershipOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *GroupMembershipOrderField `json:"field"`
}

// DefaultGroupMembershipOrder is the default ordering of GroupMembership.
var DefaultGroupMembershipOrder = &GroupMembershipOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipOrderField{
		Value: func(gm *GroupMembership) (ent.Value, error) {
			return gm.ID, nil
		},
		column: groupmembership.FieldID,
		toTerm: groupmembership.ByID,
		toCursor: func(gm *GroupMembership) Cursor {
			return Cursor{ID: gm.ID}
		},
	},
}

// ToEdge converts GroupMembership into GroupMembershipEdge.
func (gm *GroupMembership) ToEdge(order *GroupMembershipOrder) *GroupMembershipEdge {
	if order == nil {
		order = DefaultGroupMembershipOrder
	}
	return &GroupMembershipEdge{
		Node:   gm,
		Cursor: order.Field.toCursor(gm),
	}
}

// GroupMembershipApplicationEdge is the edge representation of GroupMembershipApplication.
type GroupMembershipApplicationEdge struct {
	Node   *GroupMembershipApplication `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// GroupMembershipApplicationConnection is the connection containing edges to GroupMembershipApplication.
type GroupMembershipApplicationConnection struct {
	Edges      []*GroupMembershipApplicationEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *GroupMembershipApplicationConnection) build(nodes []*GroupMembershipApplication, pager *groupmembershipapplicationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupMembershipApplication
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupMembershipApplication {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupMembershipApplication {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupMembershipApplicationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupMembershipApplicationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupMembershipApplicationPaginateOption enables pagination customization.
type GroupMembershipApplicationPaginateOption func(*groupmembershipapplicationPager) error

// WithGroupMembershipApplicationOrder configures pagination ordering.
func WithGroupMembershipApplicationOrder(order *GroupMembershipApplicationOrder) GroupMembershipApplicationPaginateOption {
	if order == nil {
		order = DefaultGroupMembershipApplicationOrder
	}
	o := *order
	return func(pager *groupmembershipapplicationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupMembershipApplicationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupMembershipApplicationFilter configures pagination filter.
func WithGroupMembershipApplicationFilter(filter func(*GroupMembershipApplicationQuery) (*GroupMembershipApplicationQuery, error)) GroupMembershipApplicationPaginateOption {
	return func(pager *groupmembershipapplicationPager) error {
		if filter == nil {
			return errors.New("GroupMembershipApplicationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupmembershipapplicationPager struct {
	reverse bool
	order   *GroupMembershipApplicationOrder
	filter  func(*GroupMembershipApplicationQuery) (*GroupMembershipApplicationQuery, error)
}

func newGroupMembershipApplicationPager(opts []GroupMembershipApplicationPaginateOption, reverse bool) (*groupmembershipapplicationPager, error) {
	pager := &groupmembershipapplicationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupMembershipApplicationOrder
	}
	return pager, nil
}

func (p *groupmembershipapplicationPager) applyFilter(query *GroupMembershipApplicationQuery) (*GroupMembershipApplicationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupmembershipapplicationPager) toCursor(gma *GroupMembershipApplication) Cursor {
	return p.order.Field.toCursor(gma)
}

func (p *groupmembershipapplicationPager) applyCursors(query *GroupMembershipApplicationQuery, after, before *Cursor) (*GroupMembershipApplicationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupMembershipApplicationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupmembershipapplicationPager) applyOrder(query *GroupMembershipApplicationQuery) *GroupMembershipApplicationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupMembershipApplicationOrder.Field {
		query = query.Order(DefaultGroupMembershipApplicationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupmembershipapplicationPager) orderExpr(query *GroupMembershipApplicationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupMembershipApplicationOrder.Field {
			b.Comma().Ident(DefaultGroupMembershipApplicationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupMembershipApplication.
func (gma *GroupMembershipApplicationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupMembershipApplicationPaginateOption,
) (*GroupMembershipApplicationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupMembershipApplicationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gma, err = pager.applyFilter(gma); err != nil {
		return nil, err
	}
	conn := &GroupMembershipApplicationConnection{Edges: []*GroupMembershipApplicationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gma.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gma, err = pager.applyCursors(gma, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gma.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gma.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gma = pager.applyOrder(gma)
	nodes, err := gma.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupMembershipApplicationOrderField defines the ordering field of GroupMembershipApplication.
type GroupMembershipApplicationOrderField struct {
	// Value extracts the ordering value from the given GroupMembershipApplication.
	Value    func(*GroupMembershipApplication) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupmembershipapplication.OrderOption
	toCursor func(*GroupMembershipApplication) Cursor
}

// GroupMembershipApplicationOrder defines the ordering of GroupMembershipApplication.
type GroupMembershipApplicationOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *GroupMembershipApplicationOrderField `json:"field"`
}

// DefaultGroupMembershipApplicationOrder is the default ordering of GroupMembershipApplication.
var DefaultGroupMembershipApplicationOrder = &GroupMembershipApplicationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupMembershipApplicationOrderField{
		Value: func(gma *GroupMembershipApplication) (ent.Value, error) {
			return gma.ID, nil
		},
		column: groupmembershipapplication.FieldID,
		toTerm: groupmembershipapplication.ByID,
		toCursor: func(gma *GroupMembershipApplication) Cursor {
			return Cursor{ID: gma.ID}
		},
	},
}

// ToEdge converts GroupMembershipApplication into GroupMembershipApplicationEdge.
func (gma *GroupMembershipApplication) ToEdge(order *GroupMembershipApplicationOrder) *GroupMembershipApplicationEdge {
	if order == nil {
		order = DefaultGroupMembershipApplicationOrder
	}
	return &GroupMembershipApplicationEdge{
		Node:   gma,
		Cursor: order.Field.toCursor(gma),
	}
}

// GroupSettingsEdge is the edge representation of GroupSettings.
type GroupSettingsEdge struct {
	Node   *GroupSettings `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// GroupSettingsConnection is the connection containing edges to GroupSettings.
type GroupSettingsConnection struct {
	Edges      []*GroupSettingsEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *GroupSettingsConnection) build(nodes []*GroupSettings, pager *groupsettingsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GroupSettings
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GroupSettings {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GroupSettings {
			return nodes[i]
		}
	}
	c.Edges = make([]*GroupSettingsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GroupSettingsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GroupSettingsPaginateOption enables pagination customization.
type GroupSettingsPaginateOption func(*groupsettingsPager) error

// WithGroupSettingsOrder configures pagination ordering.
func WithGroupSettingsOrder(order *GroupSettingsOrder) GroupSettingsPaginateOption {
	if order == nil {
		order = DefaultGroupSettingsOrder
	}
	o := *order
	return func(pager *groupsettingsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGroupSettingsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGroupSettingsFilter configures pagination filter.
func WithGroupSettingsFilter(filter func(*GroupSettingsQuery) (*GroupSettingsQuery, error)) GroupSettingsPaginateOption {
	return func(pager *groupsettingsPager) error {
		if filter == nil {
			return errors.New("GroupSettingsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type groupsettingsPager struct {
	reverse bool
	order   *GroupSettingsOrder
	filter  func(*GroupSettingsQuery) (*GroupSettingsQuery, error)
}

func newGroupSettingsPager(opts []GroupSettingsPaginateOption, reverse bool) (*groupsettingsPager, error) {
	pager := &groupsettingsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGroupSettingsOrder
	}
	return pager, nil
}

func (p *groupsettingsPager) applyFilter(query *GroupSettingsQuery) (*GroupSettingsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *groupsettingsPager) toCursor(gs *GroupSettings) Cursor {
	return p.order.Field.toCursor(gs)
}

func (p *groupsettingsPager) applyCursors(query *GroupSettingsQuery, after, before *Cursor) (*GroupSettingsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGroupSettingsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *groupsettingsPager) applyOrder(query *GroupSettingsQuery) *GroupSettingsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGroupSettingsOrder.Field {
		query = query.Order(DefaultGroupSettingsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *groupsettingsPager) orderExpr(query *GroupSettingsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGroupSettingsOrder.Field {
			b.Comma().Ident(DefaultGroupSettingsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GroupSettings.
func (gs *GroupSettingsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GroupSettingsPaginateOption,
) (*GroupSettingsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGroupSettingsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gs, err = pager.applyFilter(gs); err != nil {
		return nil, err
	}
	conn := &GroupSettingsConnection{Edges: []*GroupSettingsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := gs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gs, err = pager.applyCursors(gs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		gs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gs = pager.applyOrder(gs)
	nodes, err := gs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GroupSettingsOrderField defines the ordering field of GroupSettings.
type GroupSettingsOrderField struct {
	// Value extracts the ordering value from the given GroupSettings.
	Value    func(*GroupSettings) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) groupsettings.OrderOption
	toCursor func(*GroupSettings) Cursor
}

// GroupSettingsOrder defines the ordering of GroupSettings.
type GroupSettingsOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *GroupSettingsOrderField `json:"field"`
}

// DefaultGroupSettingsOrder is the default ordering of GroupSettings.
var DefaultGroupSettingsOrder = &GroupSettingsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GroupSettingsOrderField{
		Value: func(gs *GroupSettings) (ent.Value, error) {
			return gs.ID, nil
		},
		column: groupsettings.FieldID,
		toTerm: groupsettings.ByID,
		toCursor: func(gs *GroupSettings) Cursor {
			return Cursor{ID: gs.ID}
		},
	},
}

// ToEdge converts GroupSettings into GroupSettingsEdge.
func (gs *GroupSettings) ToEdge(order *GroupSettingsOrder) *GroupSettingsEdge {
	if order == nil {
		order = DefaultGroupSettingsOrder
	}
	return &GroupSettingsEdge{
		Node:   gs,
		Cursor: order.Field.toCursor(gs),
	}
}

// MatchEdge is the edge representation of Match.
type MatchEdge struct {
	Node   *Match `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// MatchConnection is the connection containing edges to Match.
type MatchConnection struct {
	Edges      []*MatchEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *MatchConnection) build(nodes []*Match, pager *matchPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Match
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Match {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Match {
			return nodes[i]
		}
	}
	c.Edges = make([]*MatchEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MatchEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MatchPaginateOption enables pagination customization.
type MatchPaginateOption func(*matchPager) error

// WithMatchOrder configures pagination ordering.
func WithMatchOrder(order *MatchOrder) MatchPaginateOption {
	if order == nil {
		order = DefaultMatchOrder
	}
	o := *order
	return func(pager *matchPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMatchOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMatchFilter configures pagination filter.
func WithMatchFilter(filter func(*MatchQuery) (*MatchQuery, error)) MatchPaginateOption {
	return func(pager *matchPager) error {
		if filter == nil {
			return errors.New("MatchQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type matchPager struct {
	reverse bool
	order   *MatchOrder
	filter  func(*MatchQuery) (*MatchQuery, error)
}

func newMatchPager(opts []MatchPaginateOption, reverse bool) (*matchPager, error) {
	pager := &matchPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMatchOrder
	}
	return pager, nil
}

func (p *matchPager) applyFilter(query *MatchQuery) (*MatchQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *matchPager) toCursor(m *Match) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *matchPager) applyCursors(query *MatchQuery, after, before *Cursor) (*MatchQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMatchOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *matchPager) applyOrder(query *MatchQuery) *MatchQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMatchOrder.Field {
		query = query.Order(DefaultMatchOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *matchPager) orderExpr(query *MatchQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMatchOrder.Field {
			b.Comma().Ident(DefaultMatchOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Match.
func (m *MatchQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MatchPaginateOption,
) (*MatchConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMatchPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MatchConnection{Edges: []*MatchEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MatchOrderField defines the ordering field of Match.
type MatchOrderField struct {
	// Value extracts the ordering value from the given Match.
	Value    func(*Match) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) match.OrderOption
	toCursor func(*Match) Cursor
}

// MatchOrder defines the ordering of Match.
type MatchOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *MatchOrderField `json:"field"`
}

// DefaultMatchOrder is the default ordering of Match.
var DefaultMatchOrder = &MatchOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MatchOrderField{
		Value: func(m *Match) (ent.Value, error) {
			return m.ID, nil
		},
		column: match.FieldID,
		toTerm: match.ByID,
		toCursor: func(m *Match) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Match into MatchEdge.
func (m *Match) ToEdge(order *MatchOrder) *MatchEdge {
	if order == nil {
		order = DefaultMatchOrder
	}
	return &MatchEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// PlayerEdge is the edge representation of Player.
type PlayerEdge struct {
	Node   *Player `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PlayerConnection is the connection containing edges to Player.
type PlayerConnection struct {
	Edges      []*PlayerEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *PlayerConnection) build(nodes []*Player, pager *playerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Player
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Player {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Player {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlayerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlayerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlayerPaginateOption enables pagination customization.
type PlayerPaginateOption func(*playerPager) error

// WithPlayerOrder configures pagination ordering.
func WithPlayerOrder(order *PlayerOrder) PlayerPaginateOption {
	if order == nil {
		order = DefaultPlayerOrder
	}
	o := *order
	return func(pager *playerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerFilter configures pagination filter.
func WithPlayerFilter(filter func(*PlayerQuery) (*PlayerQuery, error)) PlayerPaginateOption {
	return func(pager *playerPager) error {
		if filter == nil {
			return errors.New("PlayerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playerPager struct {
	reverse bool
	order   *PlayerOrder
	filter  func(*PlayerQuery) (*PlayerQuery, error)
}

func newPlayerPager(opts []PlayerPaginateOption, reverse bool) (*playerPager, error) {
	pager := &playerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerOrder
	}
	return pager, nil
}

func (p *playerPager) applyFilter(query *PlayerQuery) (*PlayerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playerPager) toCursor(pl *Player) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *playerPager) applyCursors(query *PlayerQuery, after, before *Cursor) (*PlayerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlayerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *playerPager) applyOrder(query *PlayerQuery) *PlayerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlayerOrder.Field {
		query = query.Order(DefaultPlayerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *playerPager) orderExpr(query *PlayerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlayerOrder.Field {
			b.Comma().Ident(DefaultPlayerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Player.
func (pl *PlayerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerPaginateOption,
) (*PlayerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}
	conn := &PlayerConnection{Edges: []*PlayerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pl, err = pager.applyCursors(pl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pl = pager.applyOrder(pl)
	nodes, err := pl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlayerOrderField defines the ordering field of Player.
type PlayerOrderField struct {
	// Value extracts the ordering value from the given Player.
	Value    func(*Player) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) player.OrderOption
	toCursor func(*Player) Cursor
}

// PlayerOrder defines the ordering of Player.
type PlayerOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PlayerOrderField `json:"field"`
}

// DefaultPlayerOrder is the default ordering of Player.
var DefaultPlayerOrder = &PlayerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlayerOrderField{
		Value: func(pl *Player) (ent.Value, error) {
			return pl.ID, nil
		},
		column: player.FieldID,
		toTerm: player.ByID,
		toCursor: func(pl *Player) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts Player into PlayerEdge.
func (pl *Player) ToEdge(order *PlayerOrder) *PlayerEdge {
	if order == nil {
		order = DefaultPlayerOrder
	}
	return &PlayerEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// PlayerSupervisionRequestEdge is the edge representation of PlayerSupervisionRequest.
type PlayerSupervisionRequestEdge struct {
	Node   *PlayerSupervisionRequest `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// PlayerSupervisionRequestConnection is the connection containing edges to PlayerSupervisionRequest.
type PlayerSupervisionRequestConnection struct {
	Edges      []*PlayerSupervisionRequestEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *PlayerSupervisionRequestConnection) build(nodes []*PlayerSupervisionRequest, pager *playersupervisionrequestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlayerSupervisionRequest
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlayerSupervisionRequest {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlayerSupervisionRequest {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlayerSupervisionRequestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlayerSupervisionRequestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlayerSupervisionRequestPaginateOption enables pagination customization.
type PlayerSupervisionRequestPaginateOption func(*playersupervisionrequestPager) error

// WithPlayerSupervisionRequestOrder configures pagination ordering.
func WithPlayerSupervisionRequestOrder(order *PlayerSupervisionRequestOrder) PlayerSupervisionRequestPaginateOption {
	if order == nil {
		order = DefaultPlayerSupervisionRequestOrder
	}
	o := *order
	return func(pager *playersupervisionrequestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerSupervisionRequestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerSupervisionRequestFilter configures pagination filter.
func WithPlayerSupervisionRequestFilter(filter func(*PlayerSupervisionRequestQuery) (*PlayerSupervisionRequestQuery, error)) PlayerSupervisionRequestPaginateOption {
	return func(pager *playersupervisionrequestPager) error {
		if filter == nil {
			return errors.New("PlayerSupervisionRequestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playersupervisionrequestPager struct {
	reverse bool
	order   *PlayerSupervisionRequestOrder
	filter  func(*PlayerSupervisionRequestQuery) (*PlayerSupervisionRequestQuery, error)
}

func newPlayerSupervisionRequestPager(opts []PlayerSupervisionRequestPaginateOption, reverse bool) (*playersupervisionrequestPager, error) {
	pager := &playersupervisionrequestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerSupervisionRequestOrder
	}
	return pager, nil
}

func (p *playersupervisionrequestPager) applyFilter(query *PlayerSupervisionRequestQuery) (*PlayerSupervisionRequestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playersupervisionrequestPager) toCursor(psr *PlayerSupervisionRequest) Cursor {
	return p.order.Field.toCursor(psr)
}

func (p *playersupervisionrequestPager) applyCursors(query *PlayerSupervisionRequestQuery, after, before *Cursor) (*PlayerSupervisionRequestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlayerSupervisionRequestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *playersupervisionrequestPager) applyOrder(query *PlayerSupervisionRequestQuery) *PlayerSupervisionRequestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlayerSupervisionRequestOrder.Field {
		query = query.Order(DefaultPlayerSupervisionRequestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *playersupervisionrequestPager) orderExpr(query *PlayerSupervisionRequestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlayerSupervisionRequestOrder.Field {
			b.Comma().Ident(DefaultPlayerSupervisionRequestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlayerSupervisionRequest.
func (psr *PlayerSupervisionRequestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerSupervisionRequestPaginateOption,
) (*PlayerSupervisionRequestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerSupervisionRequestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if psr, err = pager.applyFilter(psr); err != nil {
		return nil, err
	}
	conn := &PlayerSupervisionRequestConnection{Edges: []*PlayerSupervisionRequestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := psr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if psr, err = pager.applyCursors(psr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		psr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := psr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	psr = pager.applyOrder(psr)
	nodes, err := psr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlayerSupervisionRequestOrderField defines the ordering field of PlayerSupervisionRequest.
type PlayerSupervisionRequestOrderField struct {
	// Value extracts the ordering value from the given PlayerSupervisionRequest.
	Value    func(*PlayerSupervisionRequest) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) playersupervisionrequest.OrderOption
	toCursor func(*PlayerSupervisionRequest) Cursor
}

// PlayerSupervisionRequestOrder defines the ordering of PlayerSupervisionRequest.
type PlayerSupervisionRequestOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *PlayerSupervisionRequestOrderField `json:"field"`
}

// DefaultPlayerSupervisionRequestOrder is the default ordering of PlayerSupervisionRequest.
var DefaultPlayerSupervisionRequestOrder = &PlayerSupervisionRequestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlayerSupervisionRequestOrderField{
		Value: func(psr *PlayerSupervisionRequest) (ent.Value, error) {
			return psr.ID, nil
		},
		column: playersupervisionrequest.FieldID,
		toTerm: playersupervisionrequest.ByID,
		toCursor: func(psr *PlayerSupervisionRequest) Cursor {
			return Cursor{ID: psr.ID}
		},
	},
}

// ToEdge converts PlayerSupervisionRequest into PlayerSupervisionRequestEdge.
func (psr *PlayerSupervisionRequest) ToEdge(order *PlayerSupervisionRequestOrder) *PlayerSupervisionRequestEdge {
	if order == nil {
		order = DefaultPlayerSupervisionRequestOrder
	}
	return &PlayerSupervisionRequestEdge{
		Node:   psr,
		Cursor: order.Field.toCursor(psr),
	}
}

// PlayerSupervisionRequestApprovalEdge is the edge representation of PlayerSupervisionRequestApproval.
type PlayerSupervisionRequestApprovalEdge struct {
	Node   *PlayerSupervisionRequestApproval `json:"node"`
	Cursor Cursor                            `json:"cursor"`
}

// PlayerSupervisionRequestApprovalConnection is the connection containing edges to PlayerSupervisionRequestApproval.
type PlayerSupervisionRequestApprovalConnection struct {
	Edges      []*PlayerSupervisionRequestApprovalEdge `json:"edges"`
	PageInfo   PageInfo                                `json:"pageInfo"`
	TotalCount int                                     `json:"totalCount"`
}

func (c *PlayerSupervisionRequestApprovalConnection) build(nodes []*PlayerSupervisionRequestApproval, pager *playersupervisionrequestapprovalPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlayerSupervisionRequestApproval
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlayerSupervisionRequestApproval {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlayerSupervisionRequestApproval {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlayerSupervisionRequestApprovalEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlayerSupervisionRequestApprovalEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlayerSupervisionRequestApprovalPaginateOption enables pagination customization.
type PlayerSupervisionRequestApprovalPaginateOption func(*playersupervisionrequestapprovalPager) error

// WithPlayerSupervisionRequestApprovalOrder configures pagination ordering.
func WithPlayerSupervisionRequestApprovalOrder(order *PlayerSupervisionRequestApprovalOrder) PlayerSupervisionRequestApprovalPaginateOption {
	if order == nil {
		order = DefaultPlayerSupervisionRequestApprovalOrder
	}
	o := *order
	return func(pager *playersupervisionrequestapprovalPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerSupervisionRequestApprovalOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerSupervisionRequestApprovalFilter configures pagination filter.
func WithPlayerSupervisionRequestApprovalFilter(filter func(*PlayerSupervisionRequestApprovalQuery) (*PlayerSupervisionRequestApprovalQuery, error)) PlayerSupervisionRequestApprovalPaginateOption {
	return func(pager *playersupervisionrequestapprovalPager) error {
		if filter == nil {
			return errors.New("PlayerSupervisionRequestApprovalQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playersupervisionrequestapprovalPager struct {
	reverse bool
	order   *PlayerSupervisionRequestApprovalOrder
	filter  func(*PlayerSupervisionRequestApprovalQuery) (*PlayerSupervisionRequestApprovalQuery, error)
}

func newPlayerSupervisionRequestApprovalPager(opts []PlayerSupervisionRequestApprovalPaginateOption, reverse bool) (*playersupervisionrequestapprovalPager, error) {
	pager := &playersupervisionrequestapprovalPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerSupervisionRequestApprovalOrder
	}
	return pager, nil
}

func (p *playersupervisionrequestapprovalPager) applyFilter(query *PlayerSupervisionRequestApprovalQuery) (*PlayerSupervisionRequestApprovalQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playersupervisionrequestapprovalPager) toCursor(psra *PlayerSupervisionRequestApproval) Cursor {
	return p.order.Field.toCursor(psra)
}

func (p *playersupervisionrequestapprovalPager) applyCursors(query *PlayerSupervisionRequestApprovalQuery, after, before *Cursor) (*PlayerSupervisionRequestApprovalQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlayerSupervisionRequestApprovalOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *playersupervisionrequestapprovalPager) applyOrder(query *PlayerSupervisionRequestApprovalQuery) *PlayerSupervisionRequestApprovalQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlayerSupervisionRequestApprovalOrder.Field {
		query = query.Order(DefaultPlayerSupervisionRequestApprovalOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *playersupervisionrequestapprovalPager) orderExpr(query *PlayerSupervisionRequestApprovalQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlayerSupervisionRequestApprovalOrder.Field {
			b.Comma().Ident(DefaultPlayerSupervisionRequestApprovalOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlayerSupervisionRequestApproval.
func (psra *PlayerSupervisionRequestApprovalQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerSupervisionRequestApprovalPaginateOption,
) (*PlayerSupervisionRequestApprovalConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerSupervisionRequestApprovalPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if psra, err = pager.applyFilter(psra); err != nil {
		return nil, err
	}
	conn := &PlayerSupervisionRequestApprovalConnection{Edges: []*PlayerSupervisionRequestApprovalEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := psra.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if psra, err = pager.applyCursors(psra, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		psra.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := psra.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	psra = pager.applyOrder(psra)
	nodes, err := psra.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlayerSupervisionRequestApprovalOrderField defines the ordering field of PlayerSupervisionRequestApproval.
type PlayerSupervisionRequestApprovalOrderField struct {
	// Value extracts the ordering value from the given PlayerSupervisionRequestApproval.
	Value    func(*PlayerSupervisionRequestApproval) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) playersupervisionrequestapproval.OrderOption
	toCursor func(*PlayerSupervisionRequestApproval) Cursor
}

// PlayerSupervisionRequestApprovalOrder defines the ordering of PlayerSupervisionRequestApproval.
type PlayerSupervisionRequestApprovalOrder struct {
	Direction OrderDirection                              `json:"direction"`
	Field     *PlayerSupervisionRequestApprovalOrderField `json:"field"`
}

// DefaultPlayerSupervisionRequestApprovalOrder is the default ordering of PlayerSupervisionRequestApproval.
var DefaultPlayerSupervisionRequestApprovalOrder = &PlayerSupervisionRequestApprovalOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlayerSupervisionRequestApprovalOrderField{
		Value: func(psra *PlayerSupervisionRequestApproval) (ent.Value, error) {
			return psra.ID, nil
		},
		column: playersupervisionrequestapproval.FieldID,
		toTerm: playersupervisionrequestapproval.ByID,
		toCursor: func(psra *PlayerSupervisionRequestApproval) Cursor {
			return Cursor{ID: psra.ID}
		},
	},
}

// ToEdge converts PlayerSupervisionRequestApproval into PlayerSupervisionRequestApprovalEdge.
func (psra *PlayerSupervisionRequestApproval) ToEdge(order *PlayerSupervisionRequestApprovalOrder) *PlayerSupervisionRequestApprovalEdge {
	if order == nil {
		order = DefaultPlayerSupervisionRequestApprovalOrder
	}
	return &PlayerSupervisionRequestApprovalEdge{
		Node:   psra,
		Cursor: order.Field.toCursor(psra),
	}
}

// StatDescriptionEdge is the edge representation of StatDescription.
type StatDescriptionEdge struct {
	Node   *StatDescription `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// StatDescriptionConnection is the connection containing edges to StatDescription.
type StatDescriptionConnection struct {
	Edges      []*StatDescriptionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *StatDescriptionConnection) build(nodes []*StatDescription, pager *statdescriptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *StatDescription
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *StatDescription {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *StatDescription {
			return nodes[i]
		}
	}
	c.Edges = make([]*StatDescriptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StatDescriptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StatDescriptionPaginateOption enables pagination customization.
type StatDescriptionPaginateOption func(*statdescriptionPager) error

// WithStatDescriptionOrder configures pagination ordering.
func WithStatDescriptionOrder(order *StatDescriptionOrder) StatDescriptionPaginateOption {
	if order == nil {
		order = DefaultStatDescriptionOrder
	}
	o := *order
	return func(pager *statdescriptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatDescriptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatDescriptionFilter configures pagination filter.
func WithStatDescriptionFilter(filter func(*StatDescriptionQuery) (*StatDescriptionQuery, error)) StatDescriptionPaginateOption {
	return func(pager *statdescriptionPager) error {
		if filter == nil {
			return errors.New("StatDescriptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statdescriptionPager struct {
	reverse bool
	order   *StatDescriptionOrder
	filter  func(*StatDescriptionQuery) (*StatDescriptionQuery, error)
}

func newStatDescriptionPager(opts []StatDescriptionPaginateOption, reverse bool) (*statdescriptionPager, error) {
	pager := &statdescriptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatDescriptionOrder
	}
	return pager, nil
}

func (p *statdescriptionPager) applyFilter(query *StatDescriptionQuery) (*StatDescriptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statdescriptionPager) toCursor(sd *StatDescription) Cursor {
	return p.order.Field.toCursor(sd)
}

func (p *statdescriptionPager) applyCursors(query *StatDescriptionQuery, after, before *Cursor) (*StatDescriptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStatDescriptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *statdescriptionPager) applyOrder(query *StatDescriptionQuery) *StatDescriptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStatDescriptionOrder.Field {
		query = query.Order(DefaultStatDescriptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *statdescriptionPager) orderExpr(query *StatDescriptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStatDescriptionOrder.Field {
			b.Comma().Ident(DefaultStatDescriptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to StatDescription.
func (sd *StatDescriptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatDescriptionPaginateOption,
) (*StatDescriptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatDescriptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sd, err = pager.applyFilter(sd); err != nil {
		return nil, err
	}
	conn := &StatDescriptionConnection{Edges: []*StatDescriptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sd, err = pager.applyCursors(sd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sd = pager.applyOrder(sd)
	nodes, err := sd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StatDescriptionOrderField defines the ordering field of StatDescription.
type StatDescriptionOrderField struct {
	// Value extracts the ordering value from the given StatDescription.
	Value    func(*StatDescription) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) statdescription.OrderOption
	toCursor func(*StatDescription) Cursor
}

// StatDescriptionOrder defines the ordering of StatDescription.
type StatDescriptionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *StatDescriptionOrderField `json:"field"`
}

// DefaultStatDescriptionOrder is the default ordering of StatDescription.
var DefaultStatDescriptionOrder = &StatDescriptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StatDescriptionOrderField{
		Value: func(sd *StatDescription) (ent.Value, error) {
			return sd.ID, nil
		},
		column: statdescription.FieldID,
		toTerm: statdescription.ByID,
		toCursor: func(sd *StatDescription) Cursor {
			return Cursor{ID: sd.ID}
		},
	},
}

// ToEdge converts StatDescription into StatDescriptionEdge.
func (sd *StatDescription) ToEdge(order *StatDescriptionOrder) *StatDescriptionEdge {
	if order == nil {
		order = DefaultStatDescriptionOrder
	}
	return &StatDescriptionEdge{
		Node:   sd,
		Cursor: order.Field.toCursor(sd),
	}
}

// StatisticEdge is the edge representation of Statistic.
type StatisticEdge struct {
	Node   *Statistic `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// StatisticConnection is the connection containing edges to Statistic.
type StatisticConnection struct {
	Edges      []*StatisticEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *StatisticConnection) build(nodes []*Statistic, pager *statisticPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Statistic
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Statistic {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Statistic {
			return nodes[i]
		}
	}
	c.Edges = make([]*StatisticEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StatisticEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StatisticPaginateOption enables pagination customization.
type StatisticPaginateOption func(*statisticPager) error

// WithStatisticOrder configures pagination ordering.
func WithStatisticOrder(order *StatisticOrder) StatisticPaginateOption {
	if order == nil {
		order = DefaultStatisticOrder
	}
	o := *order
	return func(pager *statisticPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatisticOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatisticFilter configures pagination filter.
func WithStatisticFilter(filter func(*StatisticQuery) (*StatisticQuery, error)) StatisticPaginateOption {
	return func(pager *statisticPager) error {
		if filter == nil {
			return errors.New("StatisticQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statisticPager struct {
	reverse bool
	order   *StatisticOrder
	filter  func(*StatisticQuery) (*StatisticQuery, error)
}

func newStatisticPager(opts []StatisticPaginateOption, reverse bool) (*statisticPager, error) {
	pager := &statisticPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatisticOrder
	}
	return pager, nil
}

func (p *statisticPager) applyFilter(query *StatisticQuery) (*StatisticQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statisticPager) toCursor(s *Statistic) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statisticPager) applyCursors(query *StatisticQuery, after, before *Cursor) (*StatisticQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStatisticOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *statisticPager) applyOrder(query *StatisticQuery) *StatisticQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStatisticOrder.Field {
		query = query.Order(DefaultStatisticOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *statisticPager) orderExpr(query *StatisticQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStatisticOrder.Field {
			b.Comma().Ident(DefaultStatisticOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Statistic.
func (s *StatisticQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatisticPaginateOption,
) (*StatisticConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatisticPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &StatisticConnection{Edges: []*StatisticEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StatisticOrderField defines the ordering field of Statistic.
type StatisticOrderField struct {
	// Value extracts the ordering value from the given Statistic.
	Value    func(*Statistic) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) statistic.OrderOption
	toCursor func(*Statistic) Cursor
}

// StatisticOrder defines the ordering of Statistic.
type StatisticOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *StatisticOrderField `json:"field"`
}

// DefaultStatisticOrder is the default ordering of Statistic.
var DefaultStatisticOrder = &StatisticOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StatisticOrderField{
		Value: func(s *Statistic) (ent.Value, error) {
			return s.ID, nil
		},
		column: statistic.FieldID,
		toTerm: statistic.ByID,
		toCursor: func(s *Statistic) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Statistic into StatisticEdge.
func (s *Statistic) ToEdge(order *StatisticOrder) *StatisticEdge {
	if order == nil {
		order = DefaultStatisticOrder
	}
	return &StatisticEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
